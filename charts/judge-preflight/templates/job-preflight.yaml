apiVersion: batch/v1
kind: Job
metadata:
  name: {{ .Release.Name }}-preflight
  namespace: {{ .Release.Namespace }}
  labels:
    app.kubernetes.io/name: judge-preflight
    app.kubernetes.io/instance: {{ .Release.Name }}
  annotations:
    argocd.argoproj.io/hook: PreSync
    argocd.argoproj.io/hook-delete-policy: BeforeHookCreation
    argocd.argoproj.io/sync-wave: "-1"
spec:
  ttlSecondsAfterFinished: 300  # Auto-delete 5 minutes after completion
  backoffLimit: 3
  template:
    metadata:
      labels:
        app.kubernetes.io/name: judge-preflight
        app.kubernetes.io/instance: {{ .Release.Name }}
    spec:
      restartPolicy: Never
      serviceAccountName: {{ .Release.Name }}-preflight
      containers:
      - name: preflight
        image: {{ .Values.image.repository }}:{{ .Values.image.tag }}
        imagePullPolicy: {{ .Values.image.pullPolicy }}
        command:
        - bash
        - -c
        - |
          set -euo pipefail

          # Install kubectl for Kubernetes checks
          echo "Installing kubectl..."
          curl -LO "https://dl.k8s.io/release/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl"
          chmod +x kubectl
          mv kubectl /usr/local/bin/

          # Verify AWS credentials are available via IRSA
          {{- if and .Values.global.aws.enabled (not .Values.global.dev) }}
          if [ -z "${AWS_REGION:-}" ]; then
            export AWS_REGION={{ .Values.global.aws.region }}
          fi
          {{- end }}

          # Color codes for output
          RED='\033[0;31m'
          GREEN='\033[0;32m'
          YELLOW='\033[1;33m'
          NC='\033[0m' # No Color

          ERRORS=0

          echo "=========================================="
          echo "Judge Platform Preflight Checks"
          echo "Environment: {{ .Values.global.secrets.vault.env | default "dev" }}"
          echo "Dev Mode: {{ .Values.global.dev }}"
          echo "=========================================="
          echo ""

          # Function to check and report
          check() {
            local name="$1"
            local cmd="$2"
            local error_msg="$3"

            echo -n "Checking $name... "
            if eval "$cmd" > /dev/null 2>&1; then
              echo -e "${GREEN}✓${NC}"
              return 0
            else
              echo -e "${RED}✗${NC}"
              echo -e "${RED}ERROR: $error_msg${NC}"
              echo ""
              ERRORS=$((ERRORS + 1))
              return 1
            fi
          }

          # Function to check with retries (for async resources like ExternalSecrets)
          check_with_retry() {
            local name="$1"
            local cmd="$2"
            local error_msg="$3"
            local max_attempts="${4:-10}"
            local retry_delay="${5:-10}"

            echo -n "Checking $name... "
            for attempt in $(seq 1 $max_attempts); do
              if eval "$cmd" > /dev/null 2>&1; then
                echo -e "${GREEN}✓${NC}"
                return 0
              fi
              if [ $attempt -lt $max_attempts ]; then
                echo -n "."
                sleep $retry_delay
              fi
            done

            echo -e "${RED}✗${NC}"
            echo -e "${RED}ERROR: $error_msg${NC}"
            echo -e "${YELLOW}Waited ${max_attempts} attempts with ${retry_delay}s delay between retries${NC}"
            echo ""
            ERRORS=$((ERRORS + 1))
            return 1
          }

          {{- if not .Values.global.dev }}
          # Check External Secrets Operator (production only)
          echo "=== External Secrets Operator ==="
          check "ESO namespace exists" \
            "kubectl get namespace external-secrets-system" \
            "External Secrets Operator namespace 'external-secrets-system' not found. Install ESO first."

          check "ESO pods running" \
            "[ \$(kubectl get pods -n external-secrets-system --field-selector=status.phase=Running --no-headers | wc -l) -ge 3 ]" \
            "External Secrets Operator has fewer than 3 running pods. Check ESO installation."
          echo ""
          {{- end }}

          {{- if .Values.services.certManager.enabled }}
          # Check cert-manager
          echo "=== Cert-manager ==="
          check "cert-manager installed" \
            "kubectl get namespace {{ .Values.services.certManager.namespace }}" \
            "cert-manager namespace not found. Install cert-manager for TLS certificate management."

          check "cert-manager webhook ready" \
            "kubectl get deployment cert-manager-webhook -n {{ .Values.services.certManager.namespace }} -o jsonpath='{.status.readyReplicas}' | grep -q '^[1-9]'" \
            "cert-manager webhook not ready. Check cert-manager installation."
          echo ""
          {{- end }}

          {{- if and (eq .Values.global.secrets.provider "vault") (not .Values.global.dev) }}
          # Check Vault connectivity via SecretStores (production only)
          echo "=== Vault Connectivity & Authentication ==="
          check "Vault server reachable" \
            "curl -k --max-time 5 {{ .Values.global.secrets.vault.server }}/v1/sys/health" \
            "Cannot reach Vault server at {{ .Values.global.secrets.vault.server }}. Check network connectivity and Vault installation."

          {{- $secretStores := list "vault-judge-api" "vault-archivista" "vault-kratos" }}
          {{- range $secretStores }}
          check "SecretStore '{{ . }}' is ready" \
            "kubectl get secretstore {{ . }} -n {{ $.Release.Namespace }} -o jsonpath='{.status.conditions[?(@.type==\"Ready\")].status}' | grep -q 'True'" \
            "SecretStore '{{ . }}' is not ready. This validates Vault connectivity and Kubernetes auth role configuration. Check ESO logs: kubectl logs -n external-secrets-system -l app.kubernetes.io/name=external-secrets"
          {{- end }}
          echo ""
          {{- end }}

          # Database connectivity check skipped - database credentials are managed by Vault/ExternalSecrets

          {{- if and .Values.global.aws.enabled (not .Values.global.dev) }}
          # Check AWS resources (production only)
          echo "=== AWS Resources ==="
          {{- $s3Buckets := list (printf "%s-judge" .Values.global.aws.prefix) (printf "%s-archivista" .Values.global.aws.prefix) }}
          {{- range $s3Buckets }}
          check "S3 bucket '{{ . }}' exists" \
            "aws s3 ls s3://{{ . }} --region {{ $.Values.global.aws.region }}" \
            "S3 bucket '{{ . }}' not found. Create bucket or check AWS permissions."
          {{- end }}

          {{- $snsTopic := printf "%s-archivista-attestations" .Values.global.aws.prefix }}
          check "SNS topic '{{ $snsTopic }}' exists" \
            "aws sns list-topics --region {{ .Values.global.aws.region }} | grep -q '{{ $snsTopic }}'" \
            "SNS topic '{{ $snsTopic }}' not found. Create topic or check AWS permissions."

          {{- $sqsQueue := printf "%s-archivista-attestations" .Values.global.aws.prefix }}
          check "SQS queue '{{ $sqsQueue }}' exists" \
            "aws sqs list-queues --region {{ .Values.global.aws.region }} | grep -q '{{ $sqsQueue }}'" \
            "SQS queue '{{ $sqsQueue }}' not found. Create queue or check AWS permissions."
          echo ""
          {{- end }}

          {{- if .Values.secrets.fulcio.enabled }}
          # Check Fulcio secret
          echo "=== Fulcio Secret ==="
          check "Fulcio secret exists" \
            "kubectl get secret {{ .Values.secrets.fulcio.name }} -n {{ .Release.Namespace }}" \
            "Fulcio server secret '{{ .Values.secrets.fulcio.name }}' not found. This secret must be copied from production or generated."

          {{- range .Values.secrets.fulcio.requiredKeys }}
          check "Fulcio secret has '{{ . }}' key" \
            "kubectl get secret {{ $.Values.secrets.fulcio.name }} -n {{ $.Release.Namespace }} -o jsonpath='{.data.{{ . }}}' | grep -q '.'" \
            "Fulcio secret is missing required key '{{ . }}'."
          {{- end }}
          echo ""
          {{- end }}

          {{- if .Values.global.dev }}
          # Check GitHub OAuth secret (dev/staging only)
          echo "=== GitHub OAuth Secret ==="
          {{- $githubSecretName := printf "%s-github-oauth" .Release.Name }}
          if ! kubectl get secret {{ $githubSecretName }} -n {{ .Release.Namespace }} > /dev/null 2>&1; then
            echo -e "${RED}✗ GitHub OAuth secret not found${NC}"
            echo ""
            echo "=========================================="
            echo "ERROR: GitHub OAuth Secret Not Found"
            echo "=========================================="
            echo ""
            echo "The secret '{{ $githubSecretName }}' does not exist."
            echo ""
            echo "To create this secret, run:"
            echo ""
            echo "  kubectl create secret generic {{ $githubSecretName }} \\"
            echo "    --namespace {{ .Release.Namespace }} \\"
            echo "    --from-literal=clientId=<your-github-client-id> \\"
            echo "    --from-literal=clientSecret=<your-github-client-secret>"
            echo ""
            echo "Obtain credentials from: https://github.com/settings/developers"
            echo "=========================================="
            ERRORS=$((ERRORS + 1))
          else
            echo -e "${GREEN}✓ GitHub OAuth secret exists${NC}"
            {{- $requiredKeys := list "clientId" "clientSecret" }}
            {{- range $requiredKeys }}
            check "GitHub OAuth has '{{ . }}' key" \
              "kubectl get secret {{ $githubSecretName }} -n {{ $.Release.Namespace }} -o jsonpath='{.data.{{ . }}}' | grep -q '.'" \
              "GitHub OAuth secret is missing required key '{{ . }}'."
            {{- end }}
          fi
          echo ""
          {{- end }}

          {{- if not .Values.global.dev }}
          # Check Secrets exist (production only)
          # Note: We check for Secret existence rather than ExternalSecret sync status
          # because ExternalSecrets may already be synced from previous deployments
          echo "=== Vault-Managed Secrets ==="
          {{- $expectedSecrets := list (printf "%s-judge-api-database" .Release.Name) (printf "%s-judge-archivista-database" .Release.Name) (printf "%s-judge-kratos" .Release.Name) }}
          {{- range $expectedSecrets }}
          check "Secret '{{ . }}' exists" \
            "kubectl get secret {{ . }} -n {{ $.Release.Namespace }}" \
            "Secret '{{ . }}' not found. Check ExternalSecret and Vault configuration. Logs: kubectl logs -n external-secrets-system -l app.kubernetes.io/name=external-secrets"

          check "Secret '{{ . }}' has data" \
            "kubectl get secret {{ . }} -n {{ $.Release.Namespace }} -o jsonpath='{.data}' | grep -q '.'" \
            "Secret '{{ . }}' exists but has no data keys. Check Vault path and ExternalSecret configuration."
          {{- end }}
          echo ""
          {{- end }}

          {{- if and .Values.global.oidc .Values.global.oidc.enabled (not .Values.global.dev) }}
          # Check GitHub OAuth Credentials (production only)
          echo "=== GitHub OAuth Credentials ==="
          {{- $kratosSecretName := printf "%s-judge-kratos" .Release.Name }}

          check "Kratos secret '{{ $kratosSecretName }}' exists" \
            "kubectl get secret {{ $kratosSecretName }} -n {{ $.Release.Namespace }}" \
            "Kratos secret '{{ $kratosSecretName }}' not found. Check ExternalSecret configuration."

          check "Kratos secret has 'oidc_github_client_id'" \
            "kubectl get secret {{ $kratosSecretName }} -n {{ $.Release.Namespace }} -o jsonpath='{.data.oidc_github_client_id}' | grep -q '.'" \
            "Kratos secret is missing 'oidc_github_client_id'. Check Vault path: {{ .Values.global.secrets.vault.env }}/kubernetes/app/{{ .Values.global.secrets.vault.project }}"

          check "Kratos secret has 'oidc_github_client_secret'" \
            "kubectl get secret {{ $kratosSecretName }} -n {{ $.Release.Namespace }} -o jsonpath='{.data.oidc_github_client_secret}' | grep -q '.'" \
            "Kratos secret is missing 'oidc_github_client_secret'. Check Vault path: {{ .Values.global.secrets.vault.env }}/kubernetes/app/{{ .Values.global.secrets.vault.project }}"

          # Validate GitHub OAuth credentials work
          echo -n "Validating GitHub OAuth credentials... "
          GITHUB_CLIENT_ID=$(kubectl get secret {{ $kratosSecretName }} -n {{ $.Release.Namespace }} -o jsonpath='{.data.oidc_github_client_id}' | base64 -d)
          GITHUB_CLIENT_SECRET=$(kubectl get secret {{ $kratosSecretName }} -n {{ $.Release.Namespace }} -o jsonpath='{.data.oidc_github_client_secret}' | base64 -d)

          if [ -z "$GITHUB_CLIENT_ID" ] || [ -z "$GITHUB_CLIENT_SECRET" ]; then
            echo -e "${RED}✗${NC}"
            echo -e "${RED}ERROR: Could not decode GitHub OAuth credentials${NC}"
            echo ""
            ERRORS=$((ERRORS + 1))
          else
            # Test credentials by calling GitHub API
            RESPONSE=$(curl -s -w "\n%{http_code}" -X POST \
              -u "$GITHUB_CLIENT_ID:$GITHUB_CLIENT_SECRET" \
              "https://api.github.com/applications/$GITHUB_CLIENT_ID/token" \
              -d '{"access_token":"invalid_token_for_validation"}')

            HTTP_CODE=$(echo "$RESPONSE" | tail -n1)
            BODY=$(echo "$RESPONSE" | head -n-1)

            # 404 with specific error means credentials are valid but token doesn't exist (expected)
            # 401 means credentials are invalid
            if [ "$HTTP_CODE" = "404" ]; then
              echo -e "${GREEN}✓${NC}"
              echo "GitHub OAuth credentials are valid"
            elif [ "$HTTP_CODE" = "401" ]; then
              echo -e "${RED}✗${NC}"
              echo -e "${RED}ERROR: GitHub OAuth credentials are INVALID${NC}"
              echo "Response: $BODY"
              echo ""
              ERRORS=$((ERRORS + 1))
            else
              echo -e "${YELLOW}⚠${NC}"
              echo -e "${YELLOW}WARNING: Unexpected response from GitHub API (HTTP $HTTP_CODE)${NC}"
              echo "Response: $BODY"
              echo "Credentials may still work, proceeding with deployment..."
              echo ""
            fi
          fi
          echo ""
          {{- end }}

          {{- if .Values.global.dev }}
          # Check PostgreSQL (dev/staging only)
          echo "=== PostgreSQL Service ==="
          {{- $postgresqlName := printf "%s-postgresql" .Release.Name }}
          check "PostgreSQL service exists" \
            "kubectl get service {{ $postgresqlName }} -n {{ .Release.Namespace }}" \
            "PostgreSQL service not found. Deploy PostgreSQL first."

          check "PostgreSQL pod ready" \
            "kubectl get statefulset {{ $postgresqlName }} -n {{ .Release.Namespace }} -o jsonpath='{.status.readyReplicas}' | grep -q '^[1-9]'" \
            "PostgreSQL pod not ready. Wait for PostgreSQL to start."
          echo ""
          {{- end }}

          {{- if .Values.global.dev }}
          # Check LocalStack (dev/staging only)
          echo "=== LocalStack Service ==="
          {{- $localstackName := printf "%s-localstack" .Release.Name }}
          check "LocalStack service exists" \
            "kubectl get service {{ $localstackName }} -n {{ .Release.Namespace }}" \
            "LocalStack service not found. Deploy LocalStack first."

          check "LocalStack pod ready" \
            "kubectl get deployment {{ $localstackName }} -n {{ .Release.Namespace }} -o jsonpath='{.status.readyReplicas}' | grep -q '^[1-9]'" \
            "LocalStack pod not ready. Wait for LocalStack to start."

          # Check LocalStack buckets exist
          {{- $localstackBuckets := list "judge-artifacts" "archivista" "archivista-attestations" }}
          {{- range $localstackBuckets }}
          check "LocalStack bucket '{{ . }}' exists" \
            "kubectl exec deployment/{{ $localstackName }} -n {{ $.Release.Namespace }} -- awslocal s3 ls s3://{{ . }}" \
            "LocalStack bucket '{{ . }}' not found. Check LocalStack initialization."
          {{- end }}
          echo ""
          {{- end }}

          # Final summary
          echo "=========================================="
          if [ $ERRORS -eq 0 ]; then
            echo -e "${GREEN}✓ All preflight checks passed!${NC}"
            echo "=========================================="
            exit 0
          else
            echo -e "${RED}✗ $ERRORS preflight check(s) failed${NC}"
            echo "=========================================="
            echo ""
            echo "Please fix the errors above before deploying Judge platform."
            exit 1
          fi
---
apiVersion: v1
kind: ServiceAccount
metadata:
  name: {{ .Release.Name }}-preflight
  namespace: {{ .Release.Namespace }}
  labels:
    app.kubernetes.io/name: judge-preflight
    app.kubernetes.io/instance: {{ .Release.Name }}
  annotations:
    argocd.argoproj.io/sync-wave: "-1"
    {{- if and .Values.global.aws.enabled .Values.global.aws.accountId (not .Values.global.dev) }}
    eks.amazonaws.com/role-arn: arn:aws:iam::{{ .Values.global.aws.accountId }}:role/{{ .Values.global.aws.prefix }}-preflight
    {{- end }}
    {{- with .Values.serviceAccount.annotations }}
    {{- toYaml . | nindent 4 }}
    {{- end }}
---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  name: {{ .Release.Name }}-preflight
  labels:
    app.kubernetes.io/name: judge-preflight
    app.kubernetes.io/instance: {{ .Release.Name }}
  annotations:
    argocd.argoproj.io/sync-wave: "-1"
rules:
- apiGroups: [""]
  resources: ["namespaces", "services", "secrets", "pods"]
  verbs: ["get", "list"]
- apiGroups: [""]
  resources: ["pods/exec"]
  verbs: ["create"]
- apiGroups: ["apps"]
  resources: ["deployments", "statefulsets"]
  verbs: ["get", "list"]
- apiGroups: ["cert-manager.io"]
  resources: ["clusterissuers", "issuers"]
  verbs: ["get", "list"]
- apiGroups: ["external-secrets.io"]
  resources: ["secretstores", "externalsecrets"]
  verbs: ["get", "list"]
---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  name: {{ .Release.Name }}-preflight
  labels:
    app.kubernetes.io/name: judge-preflight
    app.kubernetes.io/instance: {{ .Release.Name }}
  annotations:
    argocd.argoproj.io/sync-wave: "-1"
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: {{ .Release.Name }}-preflight
subjects:
- kind: ServiceAccount
  name: {{ .Release.Name }}-preflight
  namespace: {{ .Release.Namespace }}
